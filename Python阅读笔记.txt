1.tuple是一个不可变的序列, 不能对它的元素赋值
（数值型number、字符串string均为不可变的对象，而字典可以修改成功）

2.对字典的赋值成功，但是后来发生的元组赋值失败造成的
（是先对字典进行了iadd操作并且成功，而之后的tuple赋值失败报错）

3.对原有的tuple中的字典直接赋值不会成功
（变量赋值采用对象引用的方式，传递的是一个对象的内存地址---像一个指针）

4.检索名称存储在字符串中的字段，请使用以下getattr() 函数：
p = 'xxxxxxxxx'
getattr(p,'x')

5.将字典转换为命名元组:
d = {'x': 11, 'y': 22}
Point(**d)

6.控制流语句：
    if:可以有零个或多个elif零件，else零件是可选的
    for:迭代任何序列的项目（列表或string），按照它们出现在序列中的顺序
    range():迭代一系列数字
	(它是一个对象，当迭代它时，它返回所需序列的连续项，但它不是列表)

7.循环语句可能有一个else子句， 
  当循环通过列表耗尽或条件变为false时终止，输出else子句中的语句，
  但是当循环被break语句终止时不执行else子句
  
  continue---继续循环的下一次迭代
8.注释__annotations__作为字典存储在函数的属性中，对函数的任何其他部分没有影响。
  
   参数注释由参数名称后面的冒号定义，后跟一个表达式，用于评估注释的值。

   返回注释由->参数列表和表示def语句结尾的冒号之间的文字，后跟表达式定义。
9.   Formatter定义了以下可覆盖的方法：

    -  get_value（key，args，kwargs）
    -  check_unused_args（used_args，args，kwargs）
    -  format_field（value，format_spec）

   'get_value'用于检索给定的字段值。'key'参数可以是整数或字符串。
   如果它是一个整数，它表示'args'中位置参数的索引; 如果它是一个字符串，那么它代表'kwargs'中的命名参数。

   'args'参数设置为'vformat'的位置参数列表，'kwargs'参数设置为位置参数字典。

   对于复合字段名称，仅为字段名称的第一个组件调用这些函数; 后续组件通过常规属性和索引操作来处理。

   因此，例如，字段表达式“0.name”将导致使用'key'参数为0调用'get_value'。
   在'get_value'返回后，通过调用内置函数来查找'name'属性getattr'功能。

   如果索引或关键字引用了不存在的项， 则应引发IndexError / KeyError。

   如果需要，'check_unused_args'用于实现对未使用参数的检查。
 
  'format_field'只是调用内置的全局'format'。提供该方法以便子类可以覆盖它。

   格式化程序代码本身生成的异常属于“ValueError”类型 - 格式字符串的实际“值”中存在错误。
     （这些内部生成的ValueError 异常相关联的文本将指示格式字符串中异常的位置，以及异常的性质）

   用户代码生成的异常，跟踪记录和虚拟框架将添加到回溯堆栈，以帮助确定发生异常的字符串中的位置   
